Xss is about making websites run unintended script. This can cause stolen data, actions to be performed on behalf of the user, and more. An attacker wants a javascript payload to execute in a victims browser through a website that is unsafe and lets the script run. Three main types of Xss are reflected (a request causes malicious script to execute), stored (the bad script was stored in the server and delivered to the user), and DOM based (the client side code is vulnerable and processes information in an unsafe way). While scanning can be done, manual testing of xss involves submitting input in every entry point in an application and seeing how that input is treated in http responses and whether they are capable of executing script as well as understanding the context of how xss occurs. In the case of the DOM, you try to see where in the dok input is and if its in an exploitable place. In DOM xss a source is where a payload enters the browser and a sink is a dangerous object or function that executes the payload. Xss is prevented by filtering input, encoding the data so it isnt interpreted as code that needs to run, using content headers to specify to the browser what was meant to be sent, and content security policy.

https://portswigger.net/web-security/cross-site-scripting/contexts 

Knowing the context, which is where in the response the controllable data apears and how its processed. When the XSS context is text between HTML tags, you need to introduce some new HTML tags designed to trigger execution of JavaScript ```<script>alert(document.domain)</script>```. Maybe its in an html tag attribute, if so you can maybe close the attribute value and tag, and then start a new one. In many cases angle brackets will be blocked or encoded so maybe just the attribute can be terminated and a new one can be made that runs script ```" autofocus onfocus=alert(document.domain) x="```. Maybe the context is in a type of HTML tag attribute that itself can create a scriptable context. An example of this is using the javascript pseudo-protocol in an href attribute to execute script. ```<a href="javascript:alert(document.domain)">``` The JavaScript pseudo-protocol, denoted by javascript:, is a mechanism that allows the execution of JavaScript code directly within contexts that typically expect a Uniform Resource Identifier (URI), such as the href attribute of an <a> tag or the address bar of a web browser. Sometimes the context is in the javascript. One way is to terminate the existing script and introduce a new html tag that triggers execution like ```</script><img src=1 onerror=alert(document.domain)>```. The reason this works is that the browser first performs HTML parsing to identify the page elements including blocks of script, and only later performs JavaScript parsing to understand and execute the embedded scripts. The above payload leaves the original script broken, with an unterminated string literal. But that doesn't prevent the subsequent script being parsed and executed in the normal way. You can also break out of a string, and insert your code, and then repair so errors dont stop the execution ```'-alert(document.domain)-'```. One way applications prevent this is by replacing single quote chracters to a backslash. A backslash before a character tells the JavaScript parser that the character should be interpreted literally, and not as a special character such as a string terminator. Some mistakes from this are that the backslash character itself is not escaped. With this an attacker can use their own backslash character to neutralize the backslash that is added by the application. In this case ```\\';alert(document.domain)//``` the second backslash is treated literally not the quote. Using a WAF can prevent certain characters from entering. Good thing there are other ways of calling functions. Using the throw statement with an exception handler can pass arguments to a function without using parenthases. In this case ```onerror=alert;throw 1``` the throw throws 1 to the exception handler ehich is set to execute alert with 1 passed. More ways to do this are here: https://portswigger.net/research/xss-without-parentheses-and-semi-colons If the context is in a quoted tag attribute like an event handler, html encoding can be a workaround. The browser decodes html encoded characters before executing js, so it bypasses the server and runs on the client. JavaScript template literals are string literals that allow embedded JavaScript expressions. When the XSS context is into a JavaScript template literal, there is no need to terminate the literal. Instead, you simply need to use the ${...} syntax to embed a JavaScript expression that will be executed when the literal is processed. If you see controllable data in ` ` in script, use the template literal. 

A js sandbox is a controlled environment to run code, this environment is separated from the system. These can be bypassed in multiple ways. 
